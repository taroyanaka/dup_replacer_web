<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dup_replacer</title>
<script src="./lib/vue@3.2.36.global.prod.js"></script>
<script src="./lib/localforage@1.10.0.js"></script>
<script src="./lib/ramda.@0.28.0.js"></script>
<link rel="stylesheet" href="./lib/reset.css">
<style>
/* for positioning */
.app {
display: grid;
grid-gap: 0px;
grid-template-areas:
    "button_parent button_parent"
    "textarea_parent textarea_parent"
    "list_parent web_data_parent"
    ;
    width: 100vw;
}
.button_parent{
    grid-area: button_parent;
    display: grid;
    grid-gap: 0px;
}
.textarea_parent{
    grid-area: textarea_parent;
    width: 100vw;
}
.list_parent{
    grid-area: list_parent;
    width: 50vw;
}
.web_data_parent{
    grid-area: web_data_parent;
    width: 50vw;
}
.textarea_childs{
    display: grid;
    grid-template-areas:
    'a b d'
    'a c d';
}
.a{grid-area: a;}
.b{grid-area: b;}
.c{grid-area: c;}
.d{grid-area: d;}


/* for styling */
.textarea_parent{
    background-color: blueviolet;
}
.accent_color{
    background-color: greenyellow;
}
.accent_color_2{
    background-color: yellow;
}
</style>
</head>
<body>
<div class="app">

<div class="button_parent">
    <input type="button" value="save_data_to_all_save" @click="save_data_to_all_save">
    <input type="checkbox" id="check" v-model="in_reference_to_INDEX_0_apply_check">
</div>

<div class="textarea_parent">
    <div v-for="(DATA, INDEX) in B_C_list" class="textarea_childs">
        <textarea name="a" class="a" v-model="DATA[0]"></textarea>
        <textarea name="b" class="b" v-model="DATA[1]"></textarea>
        <textarea name="c" class="c" v-model="DATA[2]"></textarea>
        <textarea name="d" class="d" v-model="DATA[3]"></textarea>
    </div>
    <button @click="duplicate_button">duplicate_button</button>
    <textarea ref="all_result_textarea" placeholder="all_result is here">{{ all_result }}</textarea>
    <button @click="a_copy_to_clipboard_button_with_a_message_conveying_that_browser_vendor_politics_suck">all_result Copy to Clipboard</button>
</div>

<div class="list_parent">
    <div><input type="button" value="sort_by_when" @click="sort_by_when"></div>
    <div><input type="button" value="sort_by_rating" @click="sort_by_rating"></div>
    <div><input type="text" name="filter_by_text" class="filter_by_text" @input="filter_by_text" v-model="filter_text" placeholder="filter_text"></div>
    <ul>
        <li v-for="(item, index) in all_save">
        <button @click="save_data_set(index)">save_data_set</button>
        {{ item[4] }}: rating {{ item[3] }} <button @click="rating_up(index)">🔼</button><button @click="rating_down(index)">🔽</button>
        <p>{{ item }}</p>
        <button @click="save_data_delete(index)">save_data_delete</button>
        </li>
    </ul>
</div>

<div class="web_data_parent">
    <input type="text" v-model="name" class="name" placeholder="name">
    <input type="text" v-model="password" class="password" placeholder="password">
    <button @click="switch_user">switch_user</button>


    <button @click="fetch_insert_dup">fetch_insert_dup</button>
    <button @click="fetch_delete_all_dups_and_dups_parent">fetch_delete_all_dups_and_dups_parent</button>
    <input type="text" v-model="tag" class="tag" placeholder="tag">

    <div>
    <input type="text" v-model="auto_complete_tags_cunrrent_tag" @input="search_tag" class="search_tag" placeholder="search_tag"  list="autocomplete-list" />
    <datalist id="autocomplete-list">
        <option v-for="item in auto_complete_tags" :key="item" :value="item"></option>
    </datalist>
    </div>

    <ul>
        <li v-for="(TAG, TAG_INDEX) in all_tags">{{ TAG }}</li>
    </ul>

    <ul>
    <li v-for="(item, index) in response_message">
    <!-- <button>copy</button> -->
    <button class="accent_color_2" @click="fetched_data_localforage(item[0]['dups_parent_id'])">copy</button>
    <button class="accent_color_2" @click="fetch_add_tag(item[0]['dups_parent_id'])">fetch_add_tag</button>

    <button class="accent_color_2" @click="fetch_add_comment(item[0]['dups_parent_id'])">fetch_add_comment</button>
    <input type="text" v-model="comment" class="comment" placeholder="comment">
    <!-- <span>likes_count: </span><span>{{ item[0].likes_count }}</span> -->
    <button @click="fetch_like_dups_parent(item[0]['dups_parent_id'])">fetch_like_dups_parent</button>
    <button @click="fetch_delete_like_dups_parent(item[0]['dups_parent_id'])">fetch_delete_like_dups_parent</button>
    <template v-for="(ITEM_1, INDEX_1) in item">
            <!-- <span>{{ITEM_1}}</span> -->
        <div>
            <div class="accent_color">{{ INDEX_1 }}</div>
            <div><span>dups_parent_id: </span><span>{{ ITEM_1.dups_parent_id }}</span></div>
            <div><span>dups_parent_created_at: </span><span>{{ ITEM_1.dups_parent_created_at }}</span></div>
            <div><span>user_name: </span><span>{{ ITEM_1.user_name }}</span></div>
            <div><span>dups_content_group_id: </span><span>{{ ITEM_1.dups_content_group_id }}</span></div>
            <div><span>dups_content_1: </span><span>{{ ITEM_1.dups_content_1 }}</span></div>
            <div><span>dups_content_2: </span><span>{{ ITEM_1.dups_content_2 }}</span></div>
            <div><span>dups_content_3: </span><span>{{ ITEM_1.dups_content_3 }}</span></div>
            <div><span>likes_count: </span><span>{{ ITEM_1.likes_count }}</span></div>
            <div><span>tags: </span><span>{{ ITEM_1.tags ? ITEM_1.tags[0].tags : null }}</span></div>
            <!-- <div><span>comment_replies_reply: </span><span>{{ ITEM_1.comment_replies_reply ? ITEM_1.comment_replies_reply : null }}</span></div> -->
        </div>
        <div>
            <div>COMMENT</div>
            <ul>
                <li v-for="(COMMENT, COMMENT_IDX) in ITEM_1.comments_and_replies">
                    <button @click="fetch_delete_comment(COMMENT.comment_id)">fetch_delete_comment</button>
                    <span>{{ COMMENT.comment }}: </span>
                    <span>{{ COMMENT.comment_user_name }}: </span>
                    <span>{{ COMMENT.comment_created_at }}: </span>
                    <ul v-if="COMMENT.comment_reply">
                        <!-- <li v-for="(COMMENT_REPLY_ID, COMMENT_REPLY_IDX) in COMMENT.comment_reply_id.split(',')">COMMENT_REPLY_ID: {{ COMMENT_REPLY_ID }}</li> -->
                        <!-- <li v-for="(COMMENT_REPLY, COMMENT_REPLY_IDX) in COMMENT.comment_reply.split(',')">COMMENT_REPLY {{ COMMENT_REPLY }}</li> -->
                        <!-- <li v-for="(COMMENT_REPLY_CREATED_AT , COMMENT_REPLY_IDX) in COMMENT.comment_reply_created_at.split(',')">COMMENT_REPLY_CREATED_AT: {{ COMMENT_REPLY_CREATED_AT }}</li> -->
                        <!-- <li v-for="(COMMENT_REPLY_UPDATED_AT , COMMENT_REPLY_IDX) in COMMENT.comment_reply_updated_at.split(',')">COMMENT_REPLY_UPDATED_AT: {{ COMMENT_REPLY_UPDATED_AT }}</li> -->
                        <!-- <li v-for="(COMMENT_REPLY_USER_ID, COMMENT_REPLY_IDX) in COMMENT.comment_user_id.split(',')">COMMENT_REPLY_USER_ID: {{ COMMENT_REPLY_USER_ID }}</li> -->
                        <!-- <li v-for="(COMMENT_REPLY_USER_NAME , COMMENT_REPLY_IDX) in COMMENT.comment_user_name.split(',')">COMMENT_REPLY_USER_NAME: {{ COMMENT_REPLY_USER_NAME }}</li> -->
                        <!--
                        comment_reply_id
                        comment_reply
                        comment_user_name
                        -->
                        <li v-for="(ZIP_REPLY , ZIP_REPLY_IDX) in get_zip_reply(COMMENT)">
                            <!-- ZIP_REPLY: {{ ZIP_REPLY }} -->
                            <span>comment_reply_id: {{ ZIP_REPLY[0] }}</span>
                            <span>comment_reply: {{ ZIP_REPLY[1] }}</span>
                            <span>comment_user_name: {{ ZIP_REPLY[2] }}</span>
                            <button @click="fetch_delete_comment_reply(ZIP_REPLY[0])">fetch_delete_comment_reply</button>
                        </li>
                    </ul>
                    <input type="text" name="reply" class="reply" v-model="reply">
                    <button @click="fetch_add_comment_reply(COMMENT.comment_id)">fetch_add_comment_reply</button>
                </li>
                <!-- <li>COMMENT: {{ ITEM_1.comments_comment }}</li> -->
            </ul>
        </div>
    </template>
    </li>
    </ul>
</div>



</div>
</body>
<script>
const app = Vue.createApp({
data() {
return {
    B_C_list:[
        ['aaBBccDD', 'aa\nEF\nHI', 'XX\nef\nhi', ''],
    ],
    content_1: [],
    content_2: [],
    content_3: [],
    rating: 0,
    when: null,
    save_data: [],
    all_save: [],
    sort_by: 'asc',
    filter_text: '',
    temporary_all_save_for_filter: [],

    all_result: '',
    in_reference_to_INDEX_0_apply_check: true,
    name: 'name1',
    password: 'password1',
    response_message: '',
    tag: 'tag1',
    all_tags: [],
    // auto_complete_tag
    auto_complete_tags: [],
    auto_complete_tags_cunrrent_tag: '',

    comment: '',
}
},
watch: {
   B_C_list: {
     handler() {
        this.in_reference_to_INDEX_0_apply();
        this.make_result();
     },
     deep: true
   },
},
mounted() {
this.save_data_load();
this.make_result();
this.auto_resize();

this.fetch_read_dups_parent();
this.fetch_read_all_tags();
},
beforeUpdated() {
},
updated() {
},
methods: {
// const d = [4, 5, 6];
// const e = ['d', 'e', 'f'];
// const f = [7, 8, 9];
// multi_zip([d, e, f, g]); // [[4, 'd', 7], [5, 'e', 8], [6, 'f', 9]]
multi_zip(arrays){
    const length = arrays.reduce((a, b) => Math.min(a, b.length), Infinity);
    const result = [];
    for (let i = 0; i < length; i++) {
        result.push(arrays.map((array) => array[i]));
    }
    return result;
},
get_zip_reply(COMMENT){
    return this.multi_zip([
        COMMENT.comment_reply_id.split(','),
        COMMENT.comment_reply.split(','),
        COMMENT.comment_user_name.split(','),
    ])
},
refresh_save_data() {
    this.save_data = [
        this.B_C_list,
        // this.to_ary(this.B_C_list).map(V=>[V[0], V[1], V[2]]),
        this.rating,
        this.when,
    ];
},
make_result(){
    this.when = (new Date()).toLocaleString('en');
    JSON.parse(JSON.stringify(this.B_C_list)).map((B_C)=>{
        let tmp = B_C[0];
        R.zip(
            B_C[1].split("\n"),
            B_C[2].split("\n"))
                .forEach(V=> tmp = tmp.replaceAll(V[0], V[1]) );
        return tmp;
    }).forEach((item, index)=>this.B_C_list[index][3] = item);
    this.all_result = this.B_C_list.map((item)=>item[3]).join("\n");
},
async rating_up(INDEX){
    this.all_save[INDEX][1]++;
    await localforage.setItem('dup_replacer_web', JSON.stringify(this.all_save));
},
async rating_down(INDEX){
    this.all_save[INDEX][1]--;
    await localforage.setItem('dup_replacer_web', JSON.stringify(this.all_save));
},
async save_data_to_all_save(){
    this.refresh_save_data();
    this.all_save.push(this.save_data);
    await localforage.setItem('dup_replacer_web', JSON.stringify(this.all_save));
},
async save_data_load() {
    this.all_save = JSON.parse(await localforage.getItem('dup_replacer_web')) || [];
    this.temporary_all_save_for_filter = this.all_save;
},
save_data_set(INDEX){
    console.log(INDEX);
    [
        this.B_C_list,
        // [this.B_C_list[0], this.B_C_list[1], this.B_C_list[2]],
        // this.to_ary(this.B_C_list).map(V=>[V[0], V[1], V[2]]),
        this.rating,
        this.when,
    ] = this.all_save[INDEX];
},
async save_data_delete(INDEX){
    if (window.confirm("Do you really want to delete??🦖\n本当に削除する？?🦕")) {
        this.all_save.splice(INDEX, 1);
        await localforage.setItem('dup_replacer_web', JSON.stringify(this.all_save));
    }
},
sort_by_when(){
    this.all_save.sort((a, b) => {
        time_A = new Date(a[2]);
        time_B = new Date(b[2]);
        return this.sort_by === 'asc' ? time_A - time_B : time_B - time_A;
    });
    this.sort_by = this.sort_by === 'asc' ? 'desc' : 'asc';
},
sort_by_rating(){
    this.all_save.sort((a, b) => {
        return this.sort_by === 'asc' ? a[1] - b[1] : b[1] - a[1];
    });
    this.sort_by = this.sort_by === 'asc' ? 'desc' : 'asc';
},
filter_by_text(){
    this.all_save = this.temporary_all_save_for_filter.filter(VAL => {
        return VAL.join("").includes(this.filter_text);
    });
    this.filter_text === "" ? this.all_save = this.temporary_all_save_for_filter : null;
},
auto_resize(){
    document.querySelectorAll('textarea').forEach(textarea=>{
        // textarea.style.height = 'auto';
        textarea.style.height = `${textarea.scrollHeight}px`;
    });
},
duplicate_button(){
    const copy = R.clone(this.B_C_list[0]);
    this.B_C_list.push(copy);
},
in_reference_to_INDEX_0_apply(){
    this.in_reference_to_INDEX_0_apply_check === true ? this.B_C_list.forEach((item, index)=>item[0] = this.B_C_list[0][0]) : null;
},

to_ary(it){
    return JSON.parse(JSON.stringify(it));
},

a_copy_to_clipboard_button_with_a_message_conveying_that_browser_vendor_politics_suck() {
    const copyTextToClipboard = (text) => {
        const range = document.createRange();
        const selection = window.getSelection();
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        range.selectNodeContents(textarea);
        selection.removeAllRanges();
        selection.addRange(range);
        textarea.setSelectionRange(0, 999999);
        document.execCommand('copy');
        document.body.removeChild(textarea);
        console.log('Text copied to clipboard');
    }

    const copyToClipboard = () => {
        try {
            navigator.clipboard ? navigator.clipboard.writeText(this.$refs.all_result_textarea.value).then(() => console.log('Text copied to clipboard')).catch(() => {
            navigator.userAgent.match(/ipad|iphone/i) ? copyTextToClipboard(this.$refs.all_result_textarea.value) : (this.$refs.all_result_textarea.select() && document.execCommand('copy'));
            }) : (navigator.userAgent.match(/ipad|iphone/i) ? copyTextToClipboard(this.$refs.all_result_textarea.value) : (this.$refs.all_result_textarea.select() && document.execCommand('copy') && console.log('Text copied to clipboard')));
        } catch (err) {
            console.error('Failed to copy text: ', err);
        }
    }
    copyToClipboard()
},






async fetch_insert_dup(){
    const res = await fetch('http://localhost:8000/insert_dup', {method: 'POST',headers: {'Content-Type': 'application/json',},body: JSON.stringify({
            name: this.name,
            password: this.password,
            B_C_list: this.B_C_list,
        }),
    });
    const data = await res.json(); console.log(data);
    await fetch_read_dups_parent();
},

// app.get('/read_dups_parent', (req, res) => {
//     try {
//     const rows = db.prepare('SELECT dups_parent.id AS dups_parent_id, dups_parent.created_at AS dups_parent_created_at, dups_parent.updated_at AS dups_parent_updated_at, dups.content AS dups_content, dups.created_at AS dups_created_at, dups.updated_at AS dups_updated_at, users.name AS user_name, COUNT(likes.id) AS likes_count FROM dups_parent LEFT JOIN dups ON dups_parent.id = dups.dups_parent_id LEFT JOIN users ON dups_parent.user_id = users.id LEFT JOIN likes ON dups_parent.id = likes.dups_parent_id GROUP BY dups_parent.id').all();
//     res.json(rows);
//     } catch (error) {
//         console.log(error);
//         error_response(res, '原因不明のエラー' + error);
//     }
// });
async fetch_read_dups_parent(){
    const res = await fetch('http://localhost:8000/read_dups_parent', {method: 'GET',headers: {'Content-Type': 'application/json',},});
    const data = await res.json(); console.log(data);
    this.response_message = data;
},


// delete_all_dups_and_dups_parentというPOSTのリクエストを受け取るエンドポイントで、dups_parentとそれに付随するdupsを全て削除する。
// app.post('/delete_all_dups_and_dups_parent', (req, res) => {
//     try {
//     const user_with_permission = db.prepare('SELECT users.id AS user_id, users.name AS user_name, user_permission.permission AS user_permission FROM users LEFT JOIN user_permission ON users.role_id = user_permission.id WHERE users.name = ? AND users.password = ?').get(req.body.name, req.body.password) ? null : error_response(res, 'ユーザーが存在しません');
//     user_with_permission.deletable === 1 ? null : error_response(res, '削除権限がありません');
//     db.prepare('DELETE FROM dups').run() ? null : error_response(res, 'dupsを削除できませんでした');
//     db.prepare('DELETE FROM dups_parent').run() ? null : error_response(res, 'dups_parentを削除できませんでした');
//     res.json({message: 'success'});
//     } catch (error) {
//         console.log(error);
//         error_response(res, '原因不明のエラー' + error);
//     }
// })
async fetch_delete_all_dups_and_dups_parent(){
    const res = await fetch('http://localhost:8000/delete_all_dups_and_dups_parent', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({
            name: this.name,
            password: this.password,
        }),
    });
    const data = await res.json(); console.log(data);
    this.response_message = data;
},

data_convert_for_localforage(data) {
    const contentGroups = R.map(R.map(R.props(['dups_content_1', 'dups_content_2', 'dups_content_3'])), R.groupBy(R.prop('dups_content_group_id'), data));
    // return [R.values(contentGroups), 0, new Date().toLocaleString()];
    // return [R.values(contentGroups).concat(['']).flat(), 0, new Date().toLocaleString()];
    return [R.values(contentGroups).flat(), 0, new Date().toLocaleString()];
},
async fetched_data_localforage(INDEX){
    const INDEX_STRING = (INDEX).toString();
    this.refresh_save_data();
    this.all_save.push(
        this.data_convert_for_localforage(this.to_ary(this.response_message)[INDEX_STRING])
        // this.data_convert_for_localforage(this.to_ary(this.response_message)['8'])
    );
    await localforage.setItem('dup_replacer_web', JSON.stringify(this.all_save));
},

// app.post('/like_dups_parent', (req, res) => {
//     try {
//     const user_with_permission = db.prepare(`
//         SELECT users.id AS user_id, users.name AS user_name, user_permission.permission AS user_permission,
//         user_permission.deletable AS deletable,
//         user_permission.writable AS writable,
//         user_permission.readable AS readable,
//         user_permission.likable AS likable
//         FROM users
//         LEFT JOIN user_permission ON users.user_permission_id = user_permission.id
//         WHERE users.name = ? AND users.password = ?
//     `).get(req.body.name, req.body.password);
//         // console.log(user_with_permission);
//     user_with_permission.likable === 1 ? null : error_response(res, 'いいね権限がありません');
//     console.log(req.body.dups_parent_id, user_with_permission.user_id, now(), now());
//     db.prepare('INSERT INTO likes (dups_parent_id, user_id, created_at, updated_at) VALUES (?, ?, ?, ?)')
//         .run(req.body.dups_parent_id, user_with_permission.user_id, now(), now())
//             ? null : error_response(res, 'いいねを追加できませんでした');
//     res.json({message: 'success'});
//     } catch (error) {
//         console.log(error);
//         error_response(res, '原因不明のエラー' + error);
//     }
// });
async fetch_like_dups_parent(DUPS_PARENT_ID){
    const res = await fetch('http://localhost:8000/like_dups_parent', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            dups_parent_id: DUPS_PARENT_ID,
        }),
    });
    const data = await res.json(); console.log(data);
    await this.fetch_read_dups_parent();
},

// app.post('/delete_like_dups_parent', (req, res) => {
//     try {
//     const user_with_permission = get_user_with_permission(req);
//     user_with_permission.likable === 1 ? null : (()=>{throw new Error('いいね権限がありません')})();
//     // 既にいいねしているかどうかを確認する
//     const already_liked = db.prepare('SELECT * FROM likes WHERE dups_parent_id = ? AND user_id = ?').get(req.body.dups_parent_id, user_with_permission.user_id);
//     already_liked ? null : (()=>{throw new Error('いいねしていません')})();
//     db.prepare('DELETE FROM likes WHERE dups_parent_id = ? AND user_id = ?').run(req.body.dups_parent_id, user_with_permission.user_id)
//         ? null : (()=>{throw new Error('いいねを削除できませんでした')})();
//     res.json({message: 'success'});
//     } catch (error) {
//         console.log(error);
//         error_response(res, '原因不明のエラー' + error);
//     }
// });
async fetch_delete_like_dups_parent(DUPS_PARENT_ID){
    const res = await fetch('http://localhost:8000/delete_like_dups_parent', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            dups_parent_id: DUPS_PARENT_ID,
        }),
    });
    const data = await res.json(); console.log(data);
    await this.fetch_read_dups_parent();
},

// app.post('/add_tag', (req, res) => {
//     try {
//     true_if_within_10_characters_and_not_empty(req.body.tag) ? null : error_response(res, 'タグは10文字以内で入力してください');
//     const user_with_permission = db.prepare(`
//         SELECT users.id AS user_id, users.name AS user_name, user_permission.permission AS user_permission,
//         user_permission.deletable AS deletable,
//         user_permission.writable AS writable,
//         user_permission.readable AS readable,
//         user_permission.likable AS likable
//         FROM users
//         LEFT JOIN user_permission ON users.user_permission_id = user_permission.id
//         WHERE users.name = ? AND users.password = ?
//     `).get(req.body.name, req.body.password);
//     user_with_permission.writable === 1 ? null : error_response(res, '書き込み権限がありません');

//     // タグが存在しない場合は、タグを追加する
//     let tag_id = db.prepare('SELECT id FROM tags WHERE tag = ?').get(req.body.tag).id;
//     if(tag_id === null) {
//         db.prepare('INSERT INTO tags (tag) VALUES (?)').run(req.body.tag);
//         tag_id = db.prepare('SELECT id FROM tags WHERE tag = ?').get(req.body.tag).id;
//     }
//     db.prepare('INSERT INTO dups_parent_tags (dups_parent_id, tag_id, created_at, updated_at) VALUES (?, ?, ?, ?)')
//         .run(req.body.dups_parent_id, tag_id, now(), now())
//             ? null : error_response(res, 'タグを追加できませんでした');
//     res.json({message: 'success'});
//     } catch (error) {
//         console.log(error);
//         error_response(res, '原因不明のエラー' + error);
//     }
// });
async fetch_add_tag(DUPS_PARENT_ID){
    const res = await fetch('http://localhost:8000/add_tag', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            tag: this.tag,
            dups_parent_id: DUPS_PARENT_ID,
        }),
    });
    const data = await res.json(); console.log(data);
    // this.response_message = data;
    await this.fetch_read_dups_parent();
},

// app.post('/read_all_tags', (req, res) => {
//     try {
//     const user_with_permission = db.prepare(`
//         SELECT users.id AS user_id, users.name AS user_name, user_permission.permission AS user_permission,
//         user_permission.deletable AS deletable,
//         user_permission.writable AS writable,
//         user_permission.readable AS readable,
//         user_permission.likable AS likable
//         FROM users
//         LEFT JOIN user_permission ON users.user_permission_id = user_permission.id
//         WHERE users.name = ? AND users.password = ?
//     `).get(req.body.name, req.body.password);
//     user_with_permission.readable === 1 ? null : error_response(res, '読み込み権限がありません');
//     const tags = db.prepare('SELECT * FROM tags').all();
//     res.json({tags: tags});
//     } catch (error) {
//         console.log(error);
//         error_response(res, '原因不明のエラー' + error);
//     }
// });
async fetch_read_all_tags(){
    const res = await fetch('http://localhost:8000/read_all_tags', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({
            name: this.name,
            password: this.password,
        }),
    });
    const data = await res.json(); console.log(data);
    // this.response_message = data;
    this.all_tags = data.tags;
},


// app.post('/delete_tag', (req, res) => {
//     try {
//     const user_with_permission = db.prepare(`
//         SELECT users.id AS user_id, users.name AS user_name, user_permission.permission AS user_permission,
//         user_permission.deletable AS deletable,
//         user_permission.writable AS writable,
//         user_permission.readable AS readable,
//         user_permission.likable AS likable
//         FROM users
//         LEFT JOIN user_permission ON users.user_permission_id = user_permission.id
//         WHERE users.name = ? AND users.password = ?
//     `).get(req.body.name, req.body.password);
//     user_with_permission.deletable === 1 ? null : error_response(res, '削除権限がありません');
//     db.prepare('DELETE FROM dups_parent_tags WHERE tag_id = ?').run(req.body.tag_id);
//     // 中間テーブルから該当のタグが全て削除された場合、タグテーブルからも削除する
//     db.prepare('DELETE FROM tags WHERE id = ? AND id NOT IN (SELECT tag_id FROM dups_parent_tags)').run(req.body.tag_id);
//     res.json({message: 'success'});
//     } catch (error) {
//         console.log(error);
//         error_response(res, '原因不明のエラー' + error);
//     }
// });





switch_user(){
    switch (true) {
        case this.name === 'name1' && this.password === 'password1':
            this.name = 'name2'; this.password = 'password2'; break;
        case this.name === 'name2' && this.password === 'password2':
            this.name = 'GUEST'; this.password = 'GUEST_PASS'; break;
        case this.name === 'GUEST' && this.password === 'GUEST_PASS':
            this.name = 'name1'; this.password = 'password1'; break;
        default: break;
    }
},


// タグのオートコンプリートのためのAPI
// app.post('/get_tags_for_autocomplete', (req, res) => {
//     try {
//     const user_with_permission = get_user_with_permission(req);
//     user_with_permission.readable === 1 ? null : (()=>{throw new Error('読み込み権限がありません')})();
//     const tags = db.prepare(`SELECT * FROM tags WHERE tag LIKE '%${req.body.tag}%' LIMIT 100`).all();
//     res.json({message: 'success', tags});
//     } catch (error) {
//         console.log(error);
//         error_response(res, 'ERROR: ' + error);
//     }
// });

// search_tagはauto_complete_tagsとauto_complete_tags_cunrrent_tagを更新する
async search_tag(){
    this.auto_complete_tags = [];
    const res = await fetch('http://localhost:8000/get_tags_for_autocomplete', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            tag: this.auto_complete_tags_cunrrent_tag,
        }),
    });
    const data = await res.json(); console.log(data);
    const get_tags_ary = (tags) => tags.map(tag => tag.tag);
    this.auto_complete_tags = get_tags_ary(data.tags);
    // this.auto_complete_tags = data.tags;
    // this.auto_complete_tags_current_tag = this.tag;
},

// コメントを追加するAPI。コメントはdups_parentに紐づく。1つのコメントの最大文字数は1文字以上10文字以内。アカウント一つにつきコメントは1つまで。
// app.post('/add_comment', (req, res) => {
//     try {
//     const user_with_permission = get_user_with_permission(req);
//     user_with_permission.commentable === 1 ? null : (()=>{throw new Error('コメント権限がありません')})();
//     const dups_parent_id = req.body.dups_parent_id;
//     const comment = req.body.comment;
//     const user_id = req.body.user_id;
//     const user = db.prepare('SELECT * FROM users WHERE id = ?').get(user_id);
//     const dups_parent = db.prepare('SELECT * FROM dups_parent WHERE id = ?').get(dups_parent_id);
//     dups_parent.user_id !== user_id ? null : (() => { throw new Error('権限がありません'); })();
//     comment.length > 0 && comment.length <= 10 ? null : (() => { throw new Error('コメントは1文字以上10文字以内です'); })();
//     db.prepare('SELECT * FROM comments WHERE dups_parent_id = ?').get(dups_parent_id) ? null : (() => { throw new Error('コメントは1つまでです'); })();
//     db.prepare('INSERT INTO comments (dups_parent_id, comment, user_id) VALUES (?, ?, ?)').run(dups_parent_id, comment, user_id);
//     res.json({message: 'success'});
//     } catch (error) {
//     console.log(error);
//     error_response(res, 'ERROR: ' + error);
//     }
// });

async fetch_add_comment(DUPS_PARENT_ID){
    const res = await fetch('http://localhost:8000/add_comment', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            dups_parent_id: DUPS_PARENT_ID,
            comment: this.comment,
        }),
    });
    const data = await res.json(); console.log(data);
    this.comment = '';
    await this.fetch_read_dups_parent();
},

// app.post('/delete_comment', (req, res) => { // コメントを削除するAPI。コメントはdups_parentに紐づく。コメントを削除する権限はコメントしたユーザーのみ。コメントを削除すると、そのコメントに紐づくcomment_repliesも全て削除される。
//     try {
//     const user_with_permission = get_user_with_permission(req);
//     user_with_permission.commentable === 1 ? null : (()=>{throw new Error('コメント権限がありません')})();
//     db.prepara('SELECT * FROM comments WHERE id = ? AND user_id = ?').get(req.body.comment_id, user_with_permission.user_id) ? null : (()=>{throw new Error('コメントを削除する権限がありません')})();　// 該当のコメントが、そのコメントを投稿したユーザーか確認する
//     db.prepare('DELETE FROM comment_replies WHERE comment_id = ?').run(req.body.comment_id);
//     db.prepare('DELETE FROM comments WHERE id = ?').run(req.body.comment_id);
//     res.json({message: 'success'});
//     } catch (error) {
//     console.log(error);
//     error_response(res, 'ERROR: ' + error);
//     }
// });

async fetch_delete_comment(COMMENT_ID){
    const res = await fetch('http://localhost:8000/delete_comment', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            comment_id: COMMENT_ID,
        }),
    });
    const data = await res.json(); console.log(data);
    await this.fetch_read_dups_parent();
},

// comment_repliesに返信を追加するAPI。返信はcommentに紐づく。1つの返信の最大文字数は1文字以上10文字以内。アカウント一つにつき一つのコメントに対する返信は1つまで。
// app.post('/add_comment_reply', (req, res) => {
//     try {
//     const user_with_permission = get_user_with_permission(req);
//     user_with_permission.commentable === 1 ? null : (()=>{throw new Error('コメント権限がありません')})();
//     const comment_id = req.body.comment_id;
//     const reply = req.body.reply;
//     const user_id = req.body.user_id;
//     // const user = db.prepare('SELECT * FROM users WHERE id = ?').get(user_id);
//     const comment = db.prepare('SELECT * FROM comments WHERE id = ?').get(comment_id);
//     comment.user_id !== user_id ? null : (() => { throw new Error('権限がありません'); })();
//     reply.length > 0 && reply.length <= 10 ? null : (() => { throw new Error('返信は1文字以上10文字以内です'); })();
//     // アカウント一つにつき一つのコメントに対する返信は1つまで。
//     db.prepare('SELECT * FROM comment_replies WHERE comment_id = ? AND user_id = ?').get(comment_id, user_id) ? null : (() => { throw new Error('返信は1つまでです'); })();
//     db.prepare('INSERT INTO comment_replies (comment_id, reply, user_id) VALUES (?, ?, ?)').run(comment_id, reply, user_id);
//     res.json({message: 'success'});
//     } catch (error) {
//     console.log(error);
//     error_response(res, 'ERROR: ' + error);
//     }
// });
async fetch_add_comment_reply(COMMENT_ID){
    const res = await fetch('http://localhost:8000/add_comment_reply', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            comment_id: COMMENT_ID,
            reply: this.reply,
        }),
    });
    const data = await res.json(); console.log(data);
    await this.fetch_read_dups_parent();
    // this.reply = '';
    // await this.fetch_read_comment(COMMENT_ID);
},

// comment_repliesを削除するAPI。返信はcommentに紐づく。返信を削除する権限は返信したユーザーのみ
// app.post('/delete_comment_reply', (req, res) => {
//     try {
//     const user_with_permission = get_user_with_permission(req);
//     user_with_permission.commentable === 1 ? null : (()=>{throw new Error('コメント権限がありません')})();
//     const comment_reply_id = req.body.comment_reply_id;
//     const comment_reply = db.prepare('SELECT * FROM comment_replies WHERE id = ?').get(comment_reply_id);
//     const user = db.prepare('SELECT * FROM users WHERE id = ?').get(comment_reply.user_id);
//     const comment = db.prepare('SELECT * FROM comments WHERE id = ?').get(comment_reply.comment_id);
//     comment.user_id !== user.id ? null : (() => { throw new Error('権限がありません'); })();
//     db.prepare('DELETE FROM comment_replies WHERE id = ?').run(comment_reply_id);
//     res.json({message: 'success'});
//     } catch (error) {
//     console.log(error);
//     error_response(res, 'ERROR: ' + error);
//     }
// });
async fetch_delete_comment_reply(COMMENT_REPLY_ID){
    const res = await fetch('http://localhost:8000/delete_comment_reply', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            comment_reply_id: COMMENT_REPLY_ID,
        }),
    });
    const data = await res.json(); console.log(data);
    await this.fetch_read_dups_parent();
    // await this.fetch_read_comment(COMMENT_REPLY_ID);
},




}}).mount('.app');
</script>
</html>